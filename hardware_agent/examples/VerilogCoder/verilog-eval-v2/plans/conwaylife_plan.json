[{"id": "1", "content": "Define the TopModule with the input clk, input load, input data (256 bits), and output q (256 bits).\n\nRetrieved Related Information:\n- clk: input clock signal\n- load: input signal to load data into q at the next clock edge, active high synchronous\n- data: input signal representing a 256-bit vector for initial state loading\n- q: output signal representing the 16x16 current state of the game, updated every clock cycle\n\n", "source": "input  clk\ninput  load\ninput  data (256 bits)\noutput q (256 bits)", "parent_tasks": []}, {"id": "2", "content": "Implement a register to hold the current state of the 16x16 grid, which will be updated on the positive edge of the clock when the load signal is not active.\n\nRetrieved Related Information:\n- clk: input clock signal (Type:Signal)\n- load: input signal to load data into q at the next clock edge, active high synchronous (Type:Signal)\n- q: output signal representing the 16x16 current state of the game, updated every clock cycle (Type:Signal)\n\n", "source": "output q (256 bits)\nThe game state should advance by one timestep every clock cycle.", "parent_tasks": ["1"]}, {"id": "3", "content": "Implement the load functionality to update the state of the grid with the input data when the load signal is high on the positive edge of the clock.\n\nRetrieved Related Information:\n- load: input signal to load data into q at the next clock edge, active high synchronous (Type:Signal)\n\n", "source": "input  load\n(1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.", "parent_tasks": ["2"]}, {"id": "4", "content": "Implement the logic to calculate the number of neighbours for each cell in the grid, taking into account the toroidal grid properties.\n\nRetrieved Related Information:\n- clk: input clock signal (Type:Signal)\n- 2 neighbours: Cell state does not change. (Type:StateTransition)\n\n", "source": "The module should implement a \"game\" played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead).", "parent_tasks": ["3"]}, {"id": "5", "content": "Implement the logic to update the state of each cell based on the number of neighbours according to the game rules.\n\nRetrieved Related Information:\n- data: input signal representing a 256-bit vector for initial state loading.\n- q: output signal representing the 16x16 current state of the game, updated every clock cycle.\n- 0-1 neighbour: Cell becomes 0.\n- 2 neighbours: Cell state does not change.\n- 3 neighbours: Cell becomes 1.\n- 4+ neighbours: Cell becomes 0.\n\n", "source": "(1) 0-1 neighbour: Cell becomes 0.\n(2) 2 neighbours: Cell state does not change.\n(3) 3 neighbours: Cell becomes 1.\n(4) 4+ neighbours: Cell becomes 0.", "parent_tasks": ["4"]}]